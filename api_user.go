/*
全部  API 文档

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package zsgf

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// UserAPIService UserAPI service
type UserAPIService service

type ApiUserRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	id int64
	appKey string
}

func (r ApiUserRequest) Execute() (*UserApiResponse, *http.Response, error) {
	return r.ApiService.UserExecute(r)
}

/*
User 获取用户详情

根据用户ID获取用户详情

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 用户ID
 @param appKey
 @return ApiUserRequest
*/
func (a *UserAPIService) User(ctx context.Context, id int64, appKey string) ApiUserRequest {
	return ApiUserRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserApiResponse
func (a *UserAPIService) UserExecute(r ApiUserRequest) (*UserApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.User")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserClearRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
}

func (r ApiUserClearRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserClearExecute(r)
}

/*
UserClear 清空用户数据

清空用户数据

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserClearRequest
*/
func (a *UserAPIService) UserClear(ctx context.Context, appKey string) ApiUserClearRequest {
	return ApiUserClearRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserClearExecute(r ApiUserClearRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserClear")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Clear"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserCommonInterestsRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	tag *string
	skip *int32
	take *int32
}

// 兴趣标签
func (r ApiUserCommonInterestsRequest) Tag(tag string) ApiUserCommonInterestsRequest {
	r.tag = &tag
	return r
}

// 跳过的记录数
func (r ApiUserCommonInterestsRequest) Skip(skip int32) ApiUserCommonInterestsRequest {
	r.skip = &skip
	return r
}

// 获取的记录数
func (r ApiUserCommonInterestsRequest) Take(take int32) ApiUserCommonInterestsRequest {
	r.take = &take
	return r
}

func (r ApiUserCommonInterestsRequest) Execute() (*UserCommonInterestsResultApiResponse, *http.Response, error) {
	return r.ApiService.UserCommonInterestsExecute(r)
}

/*
UserCommonInterests 有共同爱好的用户推荐

推荐有共同爱好的用户

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserCommonInterestsRequest
*/
func (a *UserAPIService) UserCommonInterests(ctx context.Context, appKey string) ApiUserCommonInterestsRequest {
	return ApiUserCommonInterestsRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserCommonInterestsResultApiResponse
func (a *UserAPIService) UserCommonInterestsExecute(r ApiUserCommonInterestsRequest) (*UserCommonInterestsResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserCommonInterestsResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserCommonInterests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Friends/CommonInterests"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	} else {
		var defaultValue int32 = 0
		r.skip = &defaultValue
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "take", r.take, "form", "")
	} else {
		var defaultValue int32 = 10
		r.take = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserDeleteRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	id int64
	appKey string
}

func (r ApiUserDeleteRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserDeleteExecute(r)
}

/*
UserDelete 删除用户

根据用户ID删除用户

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 用户ID
 @param appKey
 @return ApiUserDeleteRequest
*/
func (a *UserAPIService) UserDelete(ctx context.Context, id int64, appKey string) ApiUserDeleteRequest {
	return ApiUserDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserDeleteExecute(r ApiUserDeleteRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserEmailSignInRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	emailSignInRequest *EmailSignInRequest
}

// 登录请求参数
func (r ApiUserEmailSignInRequest) EmailSignInRequest(emailSignInRequest EmailSignInRequest) ApiUserEmailSignInRequest {
	r.emailSignInRequest = &emailSignInRequest
	return r
}

func (r ApiUserEmailSignInRequest) Execute() (*TokenModelApiResponse, *http.Response, error) {
	return r.ApiService.UserEmailSignInExecute(r)
}

/*
UserEmailSignIn 邮箱登录

使用邮箱进行登录

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserEmailSignInRequest
*/
func (a *UserAPIService) UserEmailSignIn(ctx context.Context, appKey string) ApiUserEmailSignInRequest {
	return ApiUserEmailSignInRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return TokenModelApiResponse
func (a *UserAPIService) UserEmailSignInExecute(r ApiUserEmailSignInRequest) (*TokenModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserEmailSignIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/EmailSignIn"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.emailSignInRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserEmailSignUpRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	emailSignUpRequest *EmailSignUpRequest
}

// 注册请求参数
func (r ApiUserEmailSignUpRequest) EmailSignUpRequest(emailSignUpRequest EmailSignUpRequest) ApiUserEmailSignUpRequest {
	r.emailSignUpRequest = &emailSignUpRequest
	return r
}

func (r ApiUserEmailSignUpRequest) Execute() (*TokenModelApiResponse, *http.Response, error) {
	return r.ApiService.UserEmailSignUpExecute(r)
}

/*
UserEmailSignUp 邮箱注册

使用邮箱进行注册

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserEmailSignUpRequest
*/
func (a *UserAPIService) UserEmailSignUp(ctx context.Context, appKey string) ApiUserEmailSignUpRequest {
	return ApiUserEmailSignUpRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return TokenModelApiResponse
func (a *UserAPIService) UserEmailSignUpExecute(r ApiUserEmailSignUpRequest) (*TokenModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserEmailSignUp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/EmailSignUp"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.emailSignUpRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserExportRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
}

func (r ApiUserExportRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.UserExportExecute(r)
}

/*
UserExport 导出用户数据

导出所有用户数据为Excel文件

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserExportRequest
*/
func (a *UserAPIService) UserExport(ctx context.Context, appKey string) ApiUserExportRequest {
	return ApiUserExportRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return *os.File
func (a *UserAPIService) UserExportExecute(r ApiUserExportRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Export"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserFollowUserRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	userId int64
	appKey string
}

func (r ApiUserFollowUserRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserFollowUserExecute(r)
}

/*
UserFollowUser 关注用户

关注指定用户

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId 要关注的用户ID
 @param appKey
 @return ApiUserFollowUserRequest
*/
func (a *UserAPIService) UserFollowUser(ctx context.Context, userId int64, appKey string) ApiUserFollowUserRequest {
	return ApiUserFollowUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserFollowUserExecute(r ApiUserFollowUserRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserFollowUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Follower/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserFollowerPutRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	id int64
	appKey string
	followerPutModel *FollowerPutModel
}

// 更新粉丝的请求参数
func (r ApiUserFollowerPutRequest) FollowerPutModel(followerPutModel FollowerPutModel) ApiUserFollowerPutRequest {
	r.followerPutModel = &followerPutModel
	return r
}

func (r ApiUserFollowerPutRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserFollowerPutExecute(r)
}

/*
UserFollowerPut 更新粉丝

根据粉丝ID更新粉丝信息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 粉丝ID
 @param appKey
 @return ApiUserFollowerPutRequest
*/
func (a *UserAPIService) UserFollowerPut(ctx context.Context, id int64, appKey string) ApiUserFollowerPutRequest {
	return ApiUserFollowerPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserFollowerPutExecute(r ApiUserFollowerPutRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserFollowerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Follower/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.followerPutModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserFollowersRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	tag *string
	status *string
	skip *int32
	take *int32
}

// 标签
func (r ApiUserFollowersRequest) Tag(tag string) ApiUserFollowersRequest {
	r.tag = &tag
	return r
}

// 状态
func (r ApiUserFollowersRequest) Status(status string) ApiUserFollowersRequest {
	r.status = &status
	return r
}

// 跳过的记录数
func (r ApiUserFollowersRequest) Skip(skip int32) ApiUserFollowersRequest {
	r.skip = &skip
	return r
}

// 获取的记录数
func (r ApiUserFollowersRequest) Take(take int32) ApiUserFollowersRequest {
	r.take = &take
	return r
}

func (r ApiUserFollowersRequest) Execute() (*UserFollowersResultApiResponse, *http.Response, error) {
	return r.ApiService.UserFollowersExecute(r)
}

/*
UserFollowers 获取我的粉丝列表

根据条件获取我的粉丝列表

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserFollowersRequest
*/
func (a *UserAPIService) UserFollowers(ctx context.Context, appKey string) ApiUserFollowersRequest {
	return ApiUserFollowersRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserFollowersResultApiResponse
func (a *UserAPIService) UserFollowersExecute(r ApiUserFollowersRequest) (*UserFollowersResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserFollowersResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserFollowers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Followers"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	} else {
		var defaultValue int32 = 0
		r.skip = &defaultValue
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "take", r.take, "form", "")
	} else {
		var defaultValue int32 = 10
		r.take = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserFollowingRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	tag *string
	status *string
	skip *int32
	take *int32
}

// 标签
func (r ApiUserFollowingRequest) Tag(tag string) ApiUserFollowingRequest {
	r.tag = &tag
	return r
}

// 状态
func (r ApiUserFollowingRequest) Status(status string) ApiUserFollowingRequest {
	r.status = &status
	return r
}

// 跳过的记录数
func (r ApiUserFollowingRequest) Skip(skip int32) ApiUserFollowingRequest {
	r.skip = &skip
	return r
}

// 获取的记录数
func (r ApiUserFollowingRequest) Take(take int32) ApiUserFollowingRequest {
	r.take = &take
	return r
}

func (r ApiUserFollowingRequest) Execute() (*UserFollowingResultApiResponse, *http.Response, error) {
	return r.ApiService.UserFollowingExecute(r)
}

/*
UserFollowing 获取我的关注列表

根据条件获取我的关注列表

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserFollowingRequest
*/
func (a *UserAPIService) UserFollowing(ctx context.Context, appKey string) ApiUserFollowingRequest {
	return ApiUserFollowingRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserFollowingResultApiResponse
func (a *UserAPIService) UserFollowingExecute(r ApiUserFollowingRequest) (*UserFollowingResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserFollowingResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserFollowing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Following"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	} else {
		var defaultValue int32 = 0
		r.skip = &defaultValue
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "take", r.take, "form", "")
	} else {
		var defaultValue int32 = 10
		r.take = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserFriendsNearByRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	x *float64
	y *float64
	distance *int64
	appKey string
	gender *string
	ageS *int32
	ageE *int32
	tag *string
	type_ *string
	skip *int32
	take *int32
}

// 纬度
func (r ApiUserFriendsNearByRequest) X(x float64) ApiUserFriendsNearByRequest {
	r.x = &x
	return r
}

// 经度
func (r ApiUserFriendsNearByRequest) Y(y float64) ApiUserFriendsNearByRequest {
	r.y = &y
	return r
}

// 附近距离，单位：米
func (r ApiUserFriendsNearByRequest) Distance(distance int64) ApiUserFriendsNearByRequest {
	r.distance = &distance
	return r
}

// 性别
func (r ApiUserFriendsNearByRequest) Gender(gender string) ApiUserFriendsNearByRequest {
	r.gender = &gender
	return r
}

// 年龄段起始
func (r ApiUserFriendsNearByRequest) AgeS(ageS int32) ApiUserFriendsNearByRequest {
	r.ageS = &ageS
	return r
}

// 年龄段结束
func (r ApiUserFriendsNearByRequest) AgeE(ageE int32) ApiUserFriendsNearByRequest {
	r.ageE = &ageE
	return r
}

// 兴趣标签
func (r ApiUserFriendsNearByRequest) Tag(tag string) ApiUserFriendsNearByRequest {
	r.tag = &tag
	return r
}

// 分类
func (r ApiUserFriendsNearByRequest) Type_(type_ string) ApiUserFriendsNearByRequest {
	r.type_ = &type_
	return r
}

// 跳过的记录数
func (r ApiUserFriendsNearByRequest) Skip(skip int32) ApiUserFriendsNearByRequest {
	r.skip = &skip
	return r
}

// 获取的记录数
func (r ApiUserFriendsNearByRequest) Take(take int32) ApiUserFriendsNearByRequest {
	r.take = &take
	return r
}

func (r ApiUserFriendsNearByRequest) Execute() (*UserFriendsNearByResultApiResponse, *http.Response, error) {
	return r.ApiService.UserFriendsNearByExecute(r)
}

/*
UserFriendsNearBy 附近的用户推荐

推荐附近的用户

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserFriendsNearByRequest
*/
func (a *UserAPIService) UserFriendsNearBy(ctx context.Context, appKey string) ApiUserFriendsNearByRequest {
	return ApiUserFriendsNearByRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserFriendsNearByResultApiResponse
func (a *UserAPIService) UserFriendsNearByExecute(r ApiUserFriendsNearByRequest) (*UserFriendsNearByResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserFriendsNearByResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserFriendsNearBy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Friends/NearBy"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.x == nil {
		return localVarReturnValue, nil, reportError("x is required and must be specified")
	}
	if r.y == nil {
		return localVarReturnValue, nil, reportError("y is required and must be specified")
	}
	if r.distance == nil {
		return localVarReturnValue, nil, reportError("distance is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "x", r.x, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "y", r.y, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "distance", r.distance, "form", "")
	if r.gender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gender", r.gender, "form", "")
	}
	if r.ageS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ageS", r.ageS, "form", "")
	}
	if r.ageE != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ageE", r.ageE, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	} else {
		var defaultValue int32 = 0
		r.skip = &defaultValue
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "take", r.take, "form", "")
	} else {
		var defaultValue int32 = 10
		r.take = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserImportRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	check *bool
	file *os.File
}

// 是否进行检查
func (r ApiUserImportRequest) Check(check bool) ApiUserImportRequest {
	r.check = &check
	return r
}

// 导入的文件
func (r ApiUserImportRequest) File(file *os.File) ApiUserImportRequest {
	r.file = file
	return r
}

func (r ApiUserImportRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserImportExecute(r)
}

/*
UserImport 导入用户数据

导入用户数据

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserImportRequest
*/
func (a *UserAPIService) UserImport(ctx context.Context, appKey string) ApiUserImportRequest {
	return ApiUserImportRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserImportExecute(r ApiUserImportRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Import"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.check != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "check", r.check, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserLocationRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	id int64
	appKey string
}

func (r ApiUserLocationRequest) Execute() (*GeoLocationModelApiResponse, *http.Response, error) {
	return r.ApiService.UserLocationExecute(r)
}

/*
UserLocation 获取位置详情

根据位置ID获取位置详情

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 位置ID
 @param appKey
 @return ApiUserLocationRequest
*/
func (a *UserAPIService) UserLocation(ctx context.Context, id int64, appKey string) ApiUserLocationRequest {
	return ApiUserLocationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return GeoLocationModelApiResponse
func (a *UserAPIService) UserLocationExecute(r ApiUserLocationRequest) (*GeoLocationModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GeoLocationModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserLocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Location/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserLocationDeleteRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	id int64
	appKey string
}

func (r ApiUserLocationDeleteRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserLocationDeleteExecute(r)
}

/*
UserLocationDelete 删除位置

根据位置ID删除位置信息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 位置ID
 @param appKey
 @return ApiUserLocationDeleteRequest
*/
func (a *UserAPIService) UserLocationDelete(ctx context.Context, id int64, appKey string) ApiUserLocationDeleteRequest {
	return ApiUserLocationDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserLocationDeleteExecute(r ApiUserLocationDeleteRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserLocationDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Location/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserLocationPostRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	geoLocationModel *GeoLocationModel
}

// 位置信息
func (r ApiUserLocationPostRequest) GeoLocationModel(geoLocationModel GeoLocationModel) ApiUserLocationPostRequest {
	r.geoLocationModel = &geoLocationModel
	return r
}

func (r ApiUserLocationPostRequest) Execute() (*UserLocationPostResultApiResponse, *http.Response, error) {
	return r.ApiService.UserLocationPostExecute(r)
}

/*
UserLocationPost 添加位置

添加新的位置信息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserLocationPostRequest
*/
func (a *UserAPIService) UserLocationPost(ctx context.Context, appKey string) ApiUserLocationPostRequest {
	return ApiUserLocationPostRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserLocationPostResultApiResponse
func (a *UserAPIService) UserLocationPostExecute(r ApiUserLocationPostRequest) (*UserLocationPostResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserLocationPostResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserLocationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Location"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.geoLocationModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserLocationPutRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	id int64
	appKey string
	geoLocationModel *GeoLocationModel
}

// 位置信息
func (r ApiUserLocationPutRequest) GeoLocationModel(geoLocationModel GeoLocationModel) ApiUserLocationPutRequest {
	r.geoLocationModel = &geoLocationModel
	return r
}

func (r ApiUserLocationPutRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserLocationPutExecute(r)
}

/*
UserLocationPut 更新位置

根据位置ID更新位置信息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 位置ID
 @param appKey
 @return ApiUserLocationPutRequest
*/
func (a *UserAPIService) UserLocationPut(ctx context.Context, id int64, appKey string) ApiUserLocationPutRequest {
	return ApiUserLocationPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserLocationPutExecute(r ApiUserLocationPutRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserLocationPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Location/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.geoLocationModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserLocationsRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	tag *string
	type_ *string
	x *float64
	y *float64
	sphere *int64
	skip *int32
	take *int32
}

// 标签
func (r ApiUserLocationsRequest) Tag(tag string) ApiUserLocationsRequest {
	r.tag = &tag
	return r
}

// 分类
func (r ApiUserLocationsRequest) Type_(type_ string) ApiUserLocationsRequest {
	r.type_ = &type_
	return r
}

// 纬度
func (r ApiUserLocationsRequest) X(x float64) ApiUserLocationsRequest {
	r.x = &x
	return r
}

// 经度
func (r ApiUserLocationsRequest) Y(y float64) ApiUserLocationsRequest {
	r.y = &y
	return r
}

// 附近距离，单位：米
func (r ApiUserLocationsRequest) Sphere(sphere int64) ApiUserLocationsRequest {
	r.sphere = &sphere
	return r
}

// 跳过的记录数
func (r ApiUserLocationsRequest) Skip(skip int32) ApiUserLocationsRequest {
	r.skip = &skip
	return r
}

// 获取的记录数
func (r ApiUserLocationsRequest) Take(take int32) ApiUserLocationsRequest {
	r.take = &take
	return r
}

func (r ApiUserLocationsRequest) Execute() (*UserLocationsResultApiResponse, *http.Response, error) {
	return r.ApiService.UserLocationsExecute(r)
}

/*
UserLocations 获取位置列表

根据条件获取位置列表

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserLocationsRequest
*/
func (a *UserAPIService) UserLocations(ctx context.Context, appKey string) ApiUserLocationsRequest {
	return ApiUserLocationsRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserLocationsResultApiResponse
func (a *UserAPIService) UserLocationsExecute(r ApiUserLocationsRequest) (*UserLocationsResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserLocationsResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Locations"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.x != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "x", r.x, "form", "")
	}
	if r.y != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "y", r.y, "form", "")
	}
	if r.sphere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sphere", r.sphere, "form", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "take", r.take, "form", "")
	} else {
		var defaultValue int32 = 10
		r.take = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserMutualFollowersRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	skip *int32
	take *int32
}

// 跳过的记录数
func (r ApiUserMutualFollowersRequest) Skip(skip int32) ApiUserMutualFollowersRequest {
	r.skip = &skip
	return r
}

// 获取的记录数
func (r ApiUserMutualFollowersRequest) Take(take int32) ApiUserMutualFollowersRequest {
	r.take = &take
	return r
}

func (r ApiUserMutualFollowersRequest) Execute() (*UserMutualFollowersResultApiResponse, *http.Response, error) {
	return r.ApiService.UserMutualFollowersExecute(r)
}

/*
UserMutualFollowers 有共同粉丝的用户推荐

推荐有共同粉丝的用户

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserMutualFollowersRequest
*/
func (a *UserAPIService) UserMutualFollowers(ctx context.Context, appKey string) ApiUserMutualFollowersRequest {
	return ApiUserMutualFollowersRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserMutualFollowersResultApiResponse
func (a *UserAPIService) UserMutualFollowersExecute(r ApiUserMutualFollowersRequest) (*UserMutualFollowersResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserMutualFollowersResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserMutualFollowers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Friends/MutualFollowers"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	} else {
		var defaultValue int32 = 0
		r.skip = &defaultValue
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "take", r.take, "form", "")
	} else {
		var defaultValue int32 = 10
		r.take = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserMutualFollowingsRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	skip *int32
	take *int32
}

// 跳过的记录数
func (r ApiUserMutualFollowingsRequest) Skip(skip int32) ApiUserMutualFollowingsRequest {
	r.skip = &skip
	return r
}

// 获取的记录数
func (r ApiUserMutualFollowingsRequest) Take(take int32) ApiUserMutualFollowingsRequest {
	r.take = &take
	return r
}

func (r ApiUserMutualFollowingsRequest) Execute() (*UserMutualFollowingsResultApiResponse, *http.Response, error) {
	return r.ApiService.UserMutualFollowingsExecute(r)
}

/*
UserMutualFollowings 有共同关注的用户推荐

推荐有共同关注的用户

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserMutualFollowingsRequest
*/
func (a *UserAPIService) UserMutualFollowings(ctx context.Context, appKey string) ApiUserMutualFollowingsRequest {
	return ApiUserMutualFollowingsRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserMutualFollowingsResultApiResponse
func (a *UserAPIService) UserMutualFollowingsExecute(r ApiUserMutualFollowingsRequest) (*UserMutualFollowingsResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserMutualFollowingsResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserMutualFollowings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Friends/MutualFollowings"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	} else {
		var defaultValue int32 = 0
		r.skip = &defaultValue
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "take", r.take, "form", "")
	} else {
		var defaultValue int32 = 10
		r.take = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserOAuthAccountBindRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	oAuthAccountBindRequest *OAuthAccountBindRequest
}

// 绑定请求参数
func (r ApiUserOAuthAccountBindRequest) OAuthAccountBindRequest(oAuthAccountBindRequest OAuthAccountBindRequest) ApiUserOAuthAccountBindRequest {
	r.oAuthAccountBindRequest = &oAuthAccountBindRequest
	return r
}

func (r ApiUserOAuthAccountBindRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserOAuthAccountBindExecute(r)
}

/*
UserOAuthAccountBind 外部账号 绑定

绑定外部账号

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserOAuthAccountBindRequest
*/
func (a *UserAPIService) UserOAuthAccountBind(ctx context.Context, appKey string) ApiUserOAuthAccountBindRequest {
	return ApiUserOAuthAccountBindRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserOAuthAccountBindExecute(r ApiUserOAuthAccountBindRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserOAuthAccountBind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/OAuthAccountBind"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.oAuthAccountBindRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserOAuthAccountSignInRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	oAuthAccountSignInRequest *OAuthAccountSignInRequest
}

// 登录请求参数
func (r ApiUserOAuthAccountSignInRequest) OAuthAccountSignInRequest(oAuthAccountSignInRequest OAuthAccountSignInRequest) ApiUserOAuthAccountSignInRequest {
	r.oAuthAccountSignInRequest = &oAuthAccountSignInRequest
	return r
}

func (r ApiUserOAuthAccountSignInRequest) Execute() (*TokenModelApiResponse, *http.Response, error) {
	return r.ApiService.UserOAuthAccountSignInExecute(r)
}

/*
UserOAuthAccountSignIn 外部账号 登录

使用外部账号进行登录

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserOAuthAccountSignInRequest
*/
func (a *UserAPIService) UserOAuthAccountSignIn(ctx context.Context, appKey string) ApiUserOAuthAccountSignInRequest {
	return ApiUserOAuthAccountSignInRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return TokenModelApiResponse
func (a *UserAPIService) UserOAuthAccountSignInExecute(r ApiUserOAuthAccountSignInRequest) (*TokenModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserOAuthAccountSignIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/OAuthAccountSignIn"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.oAuthAccountSignInRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserOAuthAccountsRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
}

func (r ApiUserOAuthAccountsRequest) Execute() (*UserLoginsListApiResponse, *http.Response, error) {
	return r.ApiService.UserOAuthAccountsExecute(r)
}

/*
UserOAuthAccounts 外部账号 绑定列表

获取外部账号绑定列表

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserOAuthAccountsRequest
*/
func (a *UserAPIService) UserOAuthAccounts(ctx context.Context, appKey string) ApiUserOAuthAccountsRequest {
	return ApiUserOAuthAccountsRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserLoginsListApiResponse
func (a *UserAPIService) UserOAuthAccountsExecute(r ApiUserOAuthAccountsRequest) (*UserLoginsListApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserLoginsListApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserOAuthAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/OAuthAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserOAuthAccountsPutBindRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	id int64
	appKey string
	oAuthAccountPutBindRequest *OAuthAccountPutBindRequest
}

// 更新请求参数
func (r ApiUserOAuthAccountsPutBindRequest) OAuthAccountPutBindRequest(oAuthAccountPutBindRequest OAuthAccountPutBindRequest) ApiUserOAuthAccountsPutBindRequest {
	r.oAuthAccountPutBindRequest = &oAuthAccountPutBindRequest
	return r
}

func (r ApiUserOAuthAccountsPutBindRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserOAuthAccountsPutBindExecute(r)
}

/*
UserOAuthAccountsPutBind 外部账号 更新绑定

更新外部账号绑定信息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 绑定ID
 @param appKey
 @return ApiUserOAuthAccountsPutBindRequest
*/
func (a *UserAPIService) UserOAuthAccountsPutBind(ctx context.Context, id int64, appKey string) ApiUserOAuthAccountsPutBindRequest {
	return ApiUserOAuthAccountsPutBindRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserOAuthAccountsPutBindExecute(r ApiUserOAuthAccountsPutBindRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserOAuthAccountsPutBind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/OAuthAccounts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.oAuthAccountPutBindRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserOAuthAccountsUnBindRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	id int64
	appKey string
}

func (r ApiUserOAuthAccountsUnBindRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserOAuthAccountsUnBindExecute(r)
}

/*
UserOAuthAccountsUnBind 外部账号 删除绑定

删除外部账号绑定

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 绑定ID
 @param appKey
 @return ApiUserOAuthAccountsUnBindRequest
*/
func (a *UserAPIService) UserOAuthAccountsUnBind(ctx context.Context, id int64, appKey string) ApiUserOAuthAccountsUnBindRequest {
	return ApiUserOAuthAccountsUnBindRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserOAuthAccountsUnBindExecute(r ApiUserOAuthAccountsUnBindRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserOAuthAccountsUnBind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/OAuthAccounts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserPhoneSignInRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	phoneSignInRequest *PhoneSignInRequest
}

// 登录请求参数
func (r ApiUserPhoneSignInRequest) PhoneSignInRequest(phoneSignInRequest PhoneSignInRequest) ApiUserPhoneSignInRequest {
	r.phoneSignInRequest = &phoneSignInRequest
	return r
}

func (r ApiUserPhoneSignInRequest) Execute() (*TokenModelApiResponse, *http.Response, error) {
	return r.ApiService.UserPhoneSignInExecute(r)
}

/*
UserPhoneSignIn 手机登录

使用手机号码进行登录

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserPhoneSignInRequest
*/
func (a *UserAPIService) UserPhoneSignIn(ctx context.Context, appKey string) ApiUserPhoneSignInRequest {
	return ApiUserPhoneSignInRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return TokenModelApiResponse
func (a *UserAPIService) UserPhoneSignInExecute(r ApiUserPhoneSignInRequest) (*TokenModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserPhoneSignIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/PhoneSignIn"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.phoneSignInRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserPhoneSignUpRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	phoneSignUpRequest *PhoneSignUpRequest
}

// 注册请求参数
func (r ApiUserPhoneSignUpRequest) PhoneSignUpRequest(phoneSignUpRequest PhoneSignUpRequest) ApiUserPhoneSignUpRequest {
	r.phoneSignUpRequest = &phoneSignUpRequest
	return r
}

func (r ApiUserPhoneSignUpRequest) Execute() (*TokenModelApiResponse, *http.Response, error) {
	return r.ApiService.UserPhoneSignUpExecute(r)
}

/*
UserPhoneSignUp 手机注册

使用手机号码进行注册

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserPhoneSignUpRequest
*/
func (a *UserAPIService) UserPhoneSignUp(ctx context.Context, appKey string) ApiUserPhoneSignUpRequest {
	return ApiUserPhoneSignUpRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return TokenModelApiResponse
func (a *UserAPIService) UserPhoneSignUpExecute(r ApiUserPhoneSignUpRequest) (*TokenModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserPhoneSignUp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/PhoneSignUp"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.phoneSignUpRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserProfileRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
}

func (r ApiUserProfileRequest) Execute() (*UserProfileResultApiResponse, *http.Response, error) {
	return r.ApiService.UserProfileExecute(r)
}

/*
UserProfile 获取个人资料

获取当前用户的个人资料

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserProfileRequest
*/
func (a *UserAPIService) UserProfile(ctx context.Context, appKey string) ApiUserProfileRequest {
	return ApiUserProfileRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserProfileResultApiResponse
func (a *UserAPIService) UserProfileExecute(r ApiUserProfileRequest) (*UserProfileResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserProfileResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Profile"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserPutRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	id int64
	appKey string
	user *User
}

// 用户信息
func (r ApiUserPutRequest) User(user User) ApiUserPutRequest {
	r.user = &user
	return r
}

func (r ApiUserPutRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserPutExecute(r)
}

/*
UserPut 更新用户信息

根据用户ID更新用户信息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id 用户ID
 @param appKey
 @return ApiUserPutRequest
*/
func (a *UserAPIService) UserPut(ctx context.Context, id int64, appKey string) ApiUserPutRequest {
	return ApiUserPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserPutExecute(r ApiUserPutRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserQRCodePreSignInRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	qRCodePreSignInRequest *QRCodePreSignInRequest
}

// 预登陆请求参数
func (r ApiUserQRCodePreSignInRequest) QRCodePreSignInRequest(qRCodePreSignInRequest QRCodePreSignInRequest) ApiUserQRCodePreSignInRequest {
	r.qRCodePreSignInRequest = &qRCodePreSignInRequest
	return r
}

func (r ApiUserQRCodePreSignInRequest) Execute() (*Int64ApiResponse, *http.Response, error) {
	return r.ApiService.UserQRCodePreSignInExecute(r)
}

/*
UserQRCodePreSignIn 微信小程序 - 预登陆

使用微信小程序二维码进行预登陆

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserQRCodePreSignInRequest
*/
func (a *UserAPIService) UserQRCodePreSignIn(ctx context.Context, appKey string) ApiUserQRCodePreSignInRequest {
	return ApiUserQRCodePreSignInRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return Int64ApiResponse
func (a *UserAPIService) UserQRCodePreSignInExecute(r ApiUserQRCodePreSignInRequest) (*Int64ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Int64ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserQRCodePreSignIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/QRCodePreSignIn"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.qRCodePreSignInRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserQRCodeScanRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	qRCodeScanRequest *QRCodeScanRequest
}

// 扫码请求参数
func (r ApiUserQRCodeScanRequest) QRCodeScanRequest(qRCodeScanRequest QRCodeScanRequest) ApiUserQRCodeScanRequest {
	r.qRCodeScanRequest = &qRCodeScanRequest
	return r
}

func (r ApiUserQRCodeScanRequest) Execute() (*UserQRCodeScanResultApiResponse, *http.Response, error) {
	return r.ApiService.UserQRCodeScanExecute(r)
}

/*
UserQRCodeScan 微信小程序 - 扫码

使用微信小程序二维码进行扫码

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserQRCodeScanRequest
*/
func (a *UserAPIService) UserQRCodeScan(ctx context.Context, appKey string) ApiUserQRCodeScanRequest {
	return ApiUserQRCodeScanRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserQRCodeScanResultApiResponse
func (a *UserAPIService) UserQRCodeScanExecute(r ApiUserQRCodeScanRequest) (*UserQRCodeScanResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserQRCodeScanResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserQRCodeScan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/QRCodeScan"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.qRCodeScanRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserQRCodeSignInRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	qRCodeSignInRequest *QRCodeSignInRequest
}

// 登录请求参数
func (r ApiUserQRCodeSignInRequest) QRCodeSignInRequest(qRCodeSignInRequest QRCodeSignInRequest) ApiUserQRCodeSignInRequest {
	r.qRCodeSignInRequest = &qRCodeSignInRequest
	return r
}

func (r ApiUserQRCodeSignInRequest) Execute() (*TokenModelApiResponse, *http.Response, error) {
	return r.ApiService.UserQRCodeSignInExecute(r)
}

/*
UserQRCodeSignIn 微信小程序 - 网页登录

使用微信小程序二维码进行网页登录

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserQRCodeSignInRequest
*/
func (a *UserAPIService) UserQRCodeSignIn(ctx context.Context, appKey string) ApiUserQRCodeSignInRequest {
	return ApiUserQRCodeSignInRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return TokenModelApiResponse
func (a *UserAPIService) UserQRCodeSignInExecute(r ApiUserQRCodeSignInRequest) (*TokenModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserQRCodeSignIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/QRCodeSignIn"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.qRCodeSignInRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserQRCodeSignUpRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	qRCodeSignUpRequest *QRCodeSignUpRequest
}

// 注册请求参数
func (r ApiUserQRCodeSignUpRequest) QRCodeSignUpRequest(qRCodeSignUpRequest QRCodeSignUpRequest) ApiUserQRCodeSignUpRequest {
	r.qRCodeSignUpRequest = &qRCodeSignUpRequest
	return r
}

func (r ApiUserQRCodeSignUpRequest) Execute() (*TokenModelApiResponse, *http.Response, error) {
	return r.ApiService.UserQRCodeSignUpExecute(r)
}

/*
UserQRCodeSignUp 微信小程序 - 注册

使用微信小程序二维码进行注册

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserQRCodeSignUpRequest
*/
func (a *UserAPIService) UserQRCodeSignUp(ctx context.Context, appKey string) ApiUserQRCodeSignUpRequest {
	return ApiUserQRCodeSignUpRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return TokenModelApiResponse
func (a *UserAPIService) UserQRCodeSignUpExecute(r ApiUserQRCodeSignUpRequest) (*TokenModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserQRCodeSignUp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/QRCodeSignUp"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.qRCodeSignUpRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserResetPwdRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	appUserResetPwdRequest *AppUserResetPwdRequest
}

// 重置密码的请求参数
func (r ApiUserResetPwdRequest) AppUserResetPwdRequest(appUserResetPwdRequest AppUserResetPwdRequest) ApiUserResetPwdRequest {
	r.appUserResetPwdRequest = &appUserResetPwdRequest
	return r
}

func (r ApiUserResetPwdRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserResetPwdExecute(r)
}

/*
UserResetPwd 重置密码

通过手机号或邮箱重置密码

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserResetPwdRequest
*/
func (a *UserAPIService) UserResetPwd(ctx context.Context, appKey string) ApiUserResetPwdRequest {
	return ApiUserResetPwdRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserResetPwdExecute(r ApiUserResetPwdRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserResetPwd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/ResetPwd"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appUserResetPwdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSendEmailCodeRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	sendEmailCodeRequest *SendEmailCodeRequest
}

// 发送邮箱验证码的请求参数
func (r ApiUserSendEmailCodeRequest) SendEmailCodeRequest(sendEmailCodeRequest SendEmailCodeRequest) ApiUserSendEmailCodeRequest {
	r.sendEmailCodeRequest = &sendEmailCodeRequest
	return r
}

func (r ApiUserSendEmailCodeRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserSendEmailCodeExecute(r)
}

/*
UserSendEmailCode 发送邮箱验证码

发送邮箱验证码用于注册或找回密码

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserSendEmailCodeRequest
*/
func (a *UserAPIService) UserSendEmailCode(ctx context.Context, appKey string) ApiUserSendEmailCodeRequest {
	return ApiUserSendEmailCodeRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserSendEmailCodeExecute(r ApiUserSendEmailCodeRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserSendEmailCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/SendEmailCode"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendEmailCodeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSendSMSCodeRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	sendSMSCodeRequest *SendSMSCodeRequest
}

// 发送手机验证码的请求参数
func (r ApiUserSendSMSCodeRequest) SendSMSCodeRequest(sendSMSCodeRequest SendSMSCodeRequest) ApiUserSendSMSCodeRequest {
	r.sendSMSCodeRequest = &sendSMSCodeRequest
	return r
}

func (r ApiUserSendSMSCodeRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserSendSMSCodeExecute(r)
}

/*
UserSendSMSCode 发送手机验证码

发送手机验证码用于注册或找回密码

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserSendSMSCodeRequest
*/
func (a *UserAPIService) UserSendSMSCode(ctx context.Context, appKey string) ApiUserSendSMSCodeRequest {
	return ApiUserSendSMSCodeRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserSendSMSCodeExecute(r ApiUserSendSMSCodeRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserSendSMSCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/SendSMSCode"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendSMSCodeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSignInRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	signInRequest *SignInRequest
}

// 登录请求参数
func (r ApiUserSignInRequest) SignInRequest(signInRequest SignInRequest) ApiUserSignInRequest {
	r.signInRequest = &signInRequest
	return r
}

func (r ApiUserSignInRequest) Execute() (*TokenModelApiResponse, *http.Response, error) {
	return r.ApiService.UserSignInExecute(r)
}

/*
UserSignIn 账号密码 登录

使用账号密码进行登录

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserSignInRequest
*/
func (a *UserAPIService) UserSignIn(ctx context.Context, appKey string) ApiUserSignInRequest {
	return ApiUserSignInRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return TokenModelApiResponse
func (a *UserAPIService) UserSignInExecute(r ApiUserSignInRequest) (*TokenModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserSignIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/SignIn"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signInRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserSignUpRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	signUpRequest *SignUpRequest
}

// 注册请求参数
func (r ApiUserSignUpRequest) SignUpRequest(signUpRequest SignUpRequest) ApiUserSignUpRequest {
	r.signUpRequest = &signUpRequest
	return r
}

func (r ApiUserSignUpRequest) Execute() (*TokenModelApiResponse, *http.Response, error) {
	return r.ApiService.UserSignUpExecute(r)
}

/*
UserSignUp 账号密码 注册

使用账号密码进行注册

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserSignUpRequest
*/
func (a *UserAPIService) UserSignUp(ctx context.Context, appKey string) ApiUserSignUpRequest {
	return ApiUserSignUpRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return TokenModelApiResponse
func (a *UserAPIService) UserSignUpExecute(r ApiUserSignUpRequest) (*TokenModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserSignUp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/SignUp"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signUpRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserTwoFactorAuthRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
}

func (r ApiUserTwoFactorAuthRequest) Execute() (*SetupCodeApiResponse, *http.Response, error) {
	return r.ApiService.UserTwoFactorAuthExecute(r)
}

/*
UserTwoFactorAuth 双因素验证

获取双因素验证的设置信息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserTwoFactorAuthRequest
*/
func (a *UserAPIService) UserTwoFactorAuth(ctx context.Context, appKey string) ApiUserTwoFactorAuthRequest {
	return ApiUserTwoFactorAuthRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return SetupCodeApiResponse
func (a *UserAPIService) UserTwoFactorAuthExecute(r ApiUserTwoFactorAuthRequest) (*SetupCodeApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetupCodeApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserTwoFactorAuth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/TwoFactorAuth"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserUnfollowUserRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	userId int64
	appKey string
}

func (r ApiUserUnfollowUserRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserUnfollowUserExecute(r)
}

/*
UserUnfollowUser 取消关注

取消关注指定用户

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId 要取消关注的用户ID
 @param appKey
 @return ApiUserUnfollowUserRequest
*/
func (a *UserAPIService) UserUnfollowUser(ctx context.Context, userId int64, appKey string) ApiUserUnfollowUserRequest {
	return ApiUserUnfollowUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserUnfollowUserExecute(r ApiUserUnfollowUserRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserUnfollowUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Follower/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserUnionIDSignInRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	unionIDSignInRequest *UnionIDSignInRequest
}

// 登录请求参数
func (r ApiUserUnionIDSignInRequest) UnionIDSignInRequest(unionIDSignInRequest UnionIDSignInRequest) ApiUserUnionIDSignInRequest {
	r.unionIDSignInRequest = &unionIDSignInRequest
	return r
}

func (r ApiUserUnionIDSignInRequest) Execute() (*TokenModelApiResponse, *http.Response, error) {
	return r.ApiService.UserUnionIDSignInExecute(r)
}

/*
UserUnionIDSignIn UnionID登录

使用UnionID进行登录

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserUnionIDSignInRequest
*/
func (a *UserAPIService) UserUnionIDSignIn(ctx context.Context, appKey string) ApiUserUnionIDSignInRequest {
	return ApiUserUnionIDSignInRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return TokenModelApiResponse
func (a *UserAPIService) UserUnionIDSignInExecute(r ApiUserUnionIDSignInRequest) (*TokenModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserUnionIDSignIn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/UnionIDSignIn"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unionIDSignInRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserUnionIDSignUpRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	unionIDSignUpRequest *UnionIDSignUpRequest
}

// 注册请求参数
func (r ApiUserUnionIDSignUpRequest) UnionIDSignUpRequest(unionIDSignUpRequest UnionIDSignUpRequest) ApiUserUnionIDSignUpRequest {
	r.unionIDSignUpRequest = &unionIDSignUpRequest
	return r
}

func (r ApiUserUnionIDSignUpRequest) Execute() (*TokenModelApiResponse, *http.Response, error) {
	return r.ApiService.UserUnionIDSignUpExecute(r)
}

/*
UserUnionIDSignUp UnionID注册

使用UnionID进行注册

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserUnionIDSignUpRequest
*/
func (a *UserAPIService) UserUnionIDSignUp(ctx context.Context, appKey string) ApiUserUnionIDSignUpRequest {
	return ApiUserUnionIDSignUpRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return TokenModelApiResponse
func (a *UserAPIService) UserUnionIDSignUpExecute(r ApiUserUnionIDSignUpRequest) (*TokenModelApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenModelApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserUnionIDSignUp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/UnionIDSignUp"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unionIDSignUpRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserUpdateProfileRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	updateProfileRequest *UpdateProfileRequest
}

// 更新个人资料的请求参数
func (r ApiUserUpdateProfileRequest) UpdateProfileRequest(updateProfileRequest UpdateProfileRequest) ApiUserUpdateProfileRequest {
	r.updateProfileRequest = &updateProfileRequest
	return r
}

func (r ApiUserUpdateProfileRequest) Execute() (*BooleanApiResponse, *http.Response, error) {
	return r.ApiService.UserUpdateProfileExecute(r)
}

/*
UserUpdateProfile 更新个人资料

更新当前用户的个人资料

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUserUpdateProfileRequest
*/
func (a *UserAPIService) UserUpdateProfile(ctx context.Context, appKey string) ApiUserUpdateProfileRequest {
	return ApiUserUpdateProfileRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return BooleanApiResponse
func (a *UserAPIService) UserUpdateProfileExecute(r ApiUserUpdateProfileRequest) (*BooleanApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.UserUpdateProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}/Profile"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateProfileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersRequest struct {
	ctx context.Context
	ApiService *UserAPIService
	appKey string
	userName *string
	email *string
	phone *string
	platform *string
	unionId *string
	role *string
	skip *int32
	take *int32
}

// 用户名
func (r ApiUsersRequest) UserName(userName string) ApiUsersRequest {
	r.userName = &userName
	return r
}

// 邮箱
func (r ApiUsersRequest) Email(email string) ApiUsersRequest {
	r.email = &email
	return r
}

// 电话
func (r ApiUsersRequest) Phone(phone string) ApiUsersRequest {
	r.phone = &phone
	return r
}

// 平台
func (r ApiUsersRequest) Platform(platform string) ApiUsersRequest {
	r.platform = &platform
	return r
}

// 联合ID
func (r ApiUsersRequest) UnionId(unionId string) ApiUsersRequest {
	r.unionId = &unionId
	return r
}

// 角色
func (r ApiUsersRequest) Role(role string) ApiUsersRequest {
	r.role = &role
	return r
}

// 跳过的记录数
func (r ApiUsersRequest) Skip(skip int32) ApiUsersRequest {
	r.skip = &skip
	return r
}

// 获取的记录数
func (r ApiUsersRequest) Take(take int32) ApiUsersRequest {
	r.take = &take
	return r
}

func (r ApiUsersRequest) Execute() (*UserListResultApiResponse, *http.Response, error) {
	return r.ApiService.UsersExecute(r)
}

/*
Users 获取用户列表

根据条件获取用户列表

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiUsersRequest
*/
func (a *UserAPIService) Users(ctx context.Context, appKey string) ApiUsersRequest {
	return ApiUsersRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return UserListResultApiResponse
func (a *UserAPIService) UsersExecute(r ApiUsersRequest) (*UserListResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserListResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAPIService.Users")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/User/{appKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userName", r.userName, "form", "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	}
	if r.phone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "form", "")
	}
	if r.platform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platform", r.platform, "form", "")
	}
	if r.unionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unionId", r.unionId, "form", "")
	}
	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "form", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "take", r.take, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
