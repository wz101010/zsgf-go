/*
全部  API 文档

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package zsgf

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// WechatAPIService WechatAPI service
type WechatAPIService service

type ApiWechatDecryptRequest struct {
	ctx context.Context
	ApiService *WechatAPIService
	appKey string
	encryptedData *string
	iv *string
	sessionKey *string
}

// 加密的数据
func (r ApiWechatDecryptRequest) EncryptedData(encryptedData string) ApiWechatDecryptRequest {
	r.encryptedData = &encryptedData
	return r
}

// 加密算法的初始向量
func (r ApiWechatDecryptRequest) Iv(iv string) ApiWechatDecryptRequest {
	r.iv = &iv
	return r
}

// 会话密钥
func (r ApiWechatDecryptRequest) SessionKey(sessionKey string) ApiWechatDecryptRequest {
	r.sessionKey = &sessionKey
	return r
}

func (r ApiWechatDecryptRequest) Execute() (*StringApiResponse, *http.Response, error) {
	return r.ApiService.WechatDecryptExecute(r)
}

/*
WechatDecrypt 小程序-解密数据

解密小程序加密数据

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiWechatDecryptRequest
*/
func (a *WechatAPIService) WechatDecrypt(ctx context.Context, appKey string) ApiWechatDecryptRequest {
	return ApiWechatDecryptRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return StringApiResponse
func (a *WechatAPIService) WechatDecryptExecute(r ApiWechatDecryptRequest) (*StringApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WechatAPIService.WechatDecrypt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Wechat/{appKey}/Decrypt"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.encryptedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "encryptedData", r.encryptedData, "form", "")
	}
	if r.iv != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iv", r.iv, "form", "")
	}
	if r.sessionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionKey", r.sessionKey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWechatGenerateSchemeRequest struct {
	ctx context.Context
	ApiService *WechatAPIService
	appKey string
	body *interface{}
}

// scheme码数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/qrcode-link/url-scheme/generateScheme.html
func (r ApiWechatGenerateSchemeRequest) Body(body interface{}) ApiWechatGenerateSchemeRequest {
	r.body = &body
	return r
}

func (r ApiWechatGenerateSchemeRequest) Execute() (*StringApiResponse, *http.Response, error) {
	return r.ApiService.WechatGenerateSchemeExecute(r)
}

/*
WechatGenerateScheme 小程序-生成scheme码(该接口用于获取小程序 scheme 码，适用于短信、邮件、外部网页、微信内等拉起小程序的业务场景)

生成小程序的scheme码

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiWechatGenerateSchemeRequest
*/
func (a *WechatAPIService) WechatGenerateScheme(ctx context.Context, appKey string) ApiWechatGenerateSchemeRequest {
	return ApiWechatGenerateSchemeRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return StringApiResponse
func (a *WechatAPIService) WechatGenerateSchemeExecute(r ApiWechatGenerateSchemeRequest) (*StringApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WechatAPIService.WechatGenerateScheme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Wechat/{appKey}/GenerateScheme"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWechatJSCode2SessionRequest struct {
	ctx context.Context
	ApiService *WechatAPIService
	appKey string
	jsCode *string
}

// 登录凭证，开发参考：https://dwz.cn/icNajFh7
func (r ApiWechatJSCode2SessionRequest) JsCode(jsCode string) ApiWechatJSCode2SessionRequest {
	r.jsCode = &jsCode
	return r
}

func (r ApiWechatJSCode2SessionRequest) Execute() (*StringApiResponse, *http.Response, error) {
	return r.ApiService.WechatJSCode2SessionExecute(r)
}

/*
WechatJSCode2Session 小程序-登录凭证校验

校验小程序登录凭证

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiWechatJSCode2SessionRequest
*/
func (a *WechatAPIService) WechatJSCode2Session(ctx context.Context, appKey string) ApiWechatJSCode2SessionRequest {
	return ApiWechatJSCode2SessionRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return StringApiResponse
func (a *WechatAPIService) WechatJSCode2SessionExecute(r ApiWechatJSCode2SessionRequest) (*StringApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WechatAPIService.WechatJSCode2Session")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Wechat/{appKey}/JSCode2Session"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.jsCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "js_code", r.jsCode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWechatJSConfigRequest struct {
	ctx context.Context
	ApiService *WechatAPIService
	appKey string
	url *string
}

// 当前网页的URL
func (r ApiWechatJSConfigRequest) Url(url string) ApiWechatJSConfigRequest {
	r.url = &url
	return r
}

func (r ApiWechatJSConfigRequest) Execute() (*WechatJSConfigResultApiResponse, *http.Response, error) {
	return r.ApiService.WechatJSConfigExecute(r)
}

/*
WechatJSConfig 公众号H5-JS SDK Config

获取公众号H5的JS SDK配置

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiWechatJSConfigRequest
*/
func (a *WechatAPIService) WechatJSConfig(ctx context.Context, appKey string) ApiWechatJSConfigRequest {
	return ApiWechatJSConfigRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return WechatJSConfigResultApiResponse
func (a *WechatAPIService) WechatJSConfigExecute(r ApiWechatJSConfigRequest) (*WechatJSConfigResultApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WechatJSConfigResultApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WechatAPIService.WechatJSConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Wechat/{appKey}/JSConfig"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWechatSubscribeMSGRequest struct {
	ctx context.Context
	ApiService *WechatAPIService
	appKey string
	body *interface{}
}

// 订阅消息数据，开发参考：https://dwz.cn/IXptek5n
func (r ApiWechatSubscribeMSGRequest) Body(body interface{}) ApiWechatSubscribeMSGRequest {
	r.body = &body
	return r
}

func (r ApiWechatSubscribeMSGRequest) Execute() (*StringApiResponse, *http.Response, error) {
	return r.ApiService.WechatSubscribeMSGExecute(r)
}

/*
WechatSubscribeMSG 公众号H5-发送一次性订阅消息

发送公众号H5一次性订阅消息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiWechatSubscribeMSGRequest
*/
func (a *WechatAPIService) WechatSubscribeMSG(ctx context.Context, appKey string) ApiWechatSubscribeMSGRequest {
	return ApiWechatSubscribeMSGRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return StringApiResponse
func (a *WechatAPIService) WechatSubscribeMSGExecute(r ApiWechatSubscribeMSGRequest) (*StringApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WechatAPIService.WechatSubscribeMSG")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Wechat/{appKey}/SubscribeMSG"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWechatSubscribeSendRequest struct {
	ctx context.Context
	ApiService *WechatAPIService
	appKey string
	body *interface{}
}

// 订阅消息数据，开发参考：https://dwz.cn/bohXaCnp
func (r ApiWechatSubscribeSendRequest) Body(body interface{}) ApiWechatSubscribeSendRequest {
	r.body = &body
	return r
}

func (r ApiWechatSubscribeSendRequest) Execute() (*StringApiResponse, *http.Response, error) {
	return r.ApiService.WechatSubscribeSendExecute(r)
}

/*
WechatSubscribeSend 小程序-发送订阅消息

发送小程序订阅消息

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiWechatSubscribeSendRequest
*/
func (a *WechatAPIService) WechatSubscribeSend(ctx context.Context, appKey string) ApiWechatSubscribeSendRequest {
	return ApiWechatSubscribeSendRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return StringApiResponse
func (a *WechatAPIService) WechatSubscribeSendExecute(r ApiWechatSubscribeSendRequest) (*StringApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WechatAPIService.WechatSubscribeSend")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Wechat/{appKey}/SubscribeSend"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWechatUrlLinkGenerateRequest struct {
	ctx context.Context
	ApiService *WechatAPIService
	appKey string
	body *interface{}
}

// 跳转地址数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/url-link/urllink.generate.html
func (r ApiWechatUrlLinkGenerateRequest) Body(body interface{}) ApiWechatUrlLinkGenerateRequest {
	r.body = &body
	return r
}

func (r ApiWechatUrlLinkGenerateRequest) Execute() (*StringApiResponse, *http.Response, error) {
	return r.ApiService.WechatUrlLinkGenerateExecute(r)
}

/*
WechatUrlLinkGenerate 小程序-生成网页跳转地址(获取小程序 URL Link，适用于短信、邮件、网页、微信内等拉起小程序的业务场景)

生成小程序的网页跳转地址

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiWechatUrlLinkGenerateRequest
*/
func (a *WechatAPIService) WechatUrlLinkGenerate(ctx context.Context, appKey string) ApiWechatUrlLinkGenerateRequest {
	return ApiWechatUrlLinkGenerateRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return StringApiResponse
func (a *WechatAPIService) WechatUrlLinkGenerateExecute(r ApiWechatUrlLinkGenerateRequest) (*StringApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WechatAPIService.WechatUrlLinkGenerate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Wechat/{appKey}/UrlLinkGenerate"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWechatUserInfoRequest struct {
	ctx context.Context
	ApiService *WechatAPIService
	appKey string
	openid *string
}

// 用户的OpenID
func (r ApiWechatUserInfoRequest) Openid(openid string) ApiWechatUserInfoRequest {
	r.openid = &openid
	return r
}

func (r ApiWechatUserInfoRequest) Execute() (*StringApiResponse, *http.Response, error) {
	return r.ApiService.WechatUserInfoExecute(r)
}

/*
WechatUserInfo 公众号H5-获取用户UnionID

获取公众号H5用户的UnionID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiWechatUserInfoRequest
*/
func (a *WechatAPIService) WechatUserInfo(ctx context.Context, appKey string) ApiWechatUserInfoRequest {
	return ApiWechatUserInfoRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return StringApiResponse
func (a *WechatAPIService) WechatUserInfoExecute(r ApiWechatUserInfoRequest) (*StringApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WechatAPIService.WechatUserInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Wechat/{appKey}/UserInfo"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.openid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "openid", r.openid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWechatWXACodeGetRequest struct {
	ctx context.Context
	ApiService *WechatAPIService
	appKey string
	body *interface{}
}

// 小程序码数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.get.html
func (r ApiWechatWXACodeGetRequest) Body(body interface{}) ApiWechatWXACodeGetRequest {
	r.body = &body
	return r
}

func (r ApiWechatWXACodeGetRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.WechatWXACodeGetExecute(r)
}

/*
WechatWXACodeGet 小程序-获取小程序码

获取小程序码

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiWechatWXACodeGetRequest
*/
func (a *WechatAPIService) WechatWXACodeGet(ctx context.Context, appKey string) ApiWechatWXACodeGetRequest {
	return ApiWechatWXACodeGetRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return *os.File
func (a *WechatAPIService) WechatWXACodeGetExecute(r ApiWechatWXACodeGetRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WechatAPIService.WechatWXACodeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Wechat/{appKey}/WXACodeGet"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/jpeg", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWechatWXACodeGetUnlimitedRequest struct {
	ctx context.Context
	ApiService *WechatAPIService
	appKey string
	body *interface{}
}

// 小程序码数据，开发参考：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html
func (r ApiWechatWXACodeGetUnlimitedRequest) Body(body interface{}) ApiWechatWXACodeGetUnlimitedRequest {
	r.body = &body
	return r
}

func (r ApiWechatWXACodeGetUnlimitedRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.WechatWXACodeGetUnlimitedExecute(r)
}

/*
WechatWXACodeGetUnlimited 小程序-获取小程序码(无限制)

获取无限制的小程序码

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appKey
 @return ApiWechatWXACodeGetUnlimitedRequest
*/
func (a *WechatAPIService) WechatWXACodeGetUnlimited(ctx context.Context, appKey string) ApiWechatWXACodeGetUnlimitedRequest {
	return ApiWechatWXACodeGetUnlimitedRequest{
		ApiService: a,
		ctx: ctx,
		appKey: appKey,
	}
}

// Execute executes the request
//  @return *os.File
func (a *WechatAPIService) WechatWXACodeGetUnlimitedExecute(r ApiWechatWXACodeGetUnlimitedRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WechatAPIService.WechatWXACodeGetUnlimited")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Wechat/{appKey}/WXACodeGetUnlimited"
	localVarPath = strings.Replace(localVarPath, "{"+"appKey"+"}", url.PathEscape(parameterValueToString(r.appKey, "appKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/jpeg", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
